$date
	Thu Dec 21 13:59:16 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module Mux_3_by_1 $end
$var wire 32 ! a [31:0] $end
$var wire 32 " b [31:0] $end
$var wire 32 # c [31:0] $end
$var wire 2 $ s [1:0] $end
$var wire 32 % d [31:0] $end
$upscope $end
$scope module tb $end
$var wire 32 & PCPlus4D [31:0] $end
$var wire 32 ' PCD [31:0] $end
$var wire 32 ( InstrD [31:0] $end
$var reg 1 ) PCSrcE $end
$var reg 32 * PCTargetE [31:0] $end
$var reg 1 + clk $end
$var reg 1 , rst $end
$scope module dut $end
$var wire 1 ) PCSrcE $end
$var wire 32 - PCTargetE [31:0] $end
$var wire 1 + clk $end
$var wire 1 , rst $end
$var wire 32 . PC_F [31:0] $end
$var wire 32 / PCPlus4F [31:0] $end
$var wire 32 0 PCPlus4D [31:0] $end
$var wire 32 1 PCF [31:0] $end
$var wire 32 2 PCD [31:0] $end
$var wire 32 3 InstrF [31:0] $end
$var wire 32 4 InstrD [31:0] $end
$var reg 32 5 InstrF_reg [31:0] $end
$var reg 32 6 PCF_reg [31:0] $end
$var reg 32 7 PCPlus4F_reg [31:0] $end
$scope module IMEM $end
$var wire 1 , rst $end
$var wire 32 8 RD [31:0] $end
$var wire 32 9 A [31:0] $end
$upscope $end
$scope module PC_MUX $end
$var wire 32 : b [31:0] $end
$var wire 1 ) s $end
$var wire 32 ; c [31:0] $end
$var wire 32 < a [31:0] $end
$upscope $end
$scope module PC_adder $end
$var wire 32 = b [31:0] $end
$var wire 32 > c [31:0] $end
$var wire 32 ? a [31:0] $end
$upscope $end
$scope module Program_Counter $end
$var wire 32 @ PC_Next [31:0] $end
$var wire 1 + clk $end
$var wire 1 , rst $end
$var reg 32 A PC [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx A
bx @
bx ?
bx >
b100 =
bx <
bx ;
bx :
bx 9
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
bx 1
b0 0
bx /
bx .
bx -
0,
0+
bx *
x)
b0 (
b0 '
b0 &
bx %
bz $
bz #
bz "
bz !
$end
#50
b100 /
b100 <
b100 >
b0 1
b0 9
b0 ?
b0 A
1+
#100
0+
#150
1+
#200
b10100000000001010010011 3
b10100000000001010010011 8
b100 .
b100 ;
b100 @
b0 *
b0 -
b0 :
0)
1,
0+
#250
b1100000000001100010011 3
b1100000000001100010011 8
b1000 .
b1000 ;
b1000 @
b100 &
b100 0
b10100000000001010010011 (
b10100000000001010010011 4
b1000 /
b1000 <
b1000 >
b100 1
b100 9
b100 ?
b100 A
b100 7
b10100000000001010010011 5
1+
#300
0+
#350
b11000101000001110110011 3
b11000101000001110110011 8
b1100 .
b1100 ;
b1100 @
b1000 &
b1000 0
b100 '
b100 2
b1100000000001100010011 (
b1100000000001100010011 4
b1100 /
b1100 <
b1100 >
b1000 1
b1000 9
b1000 ?
b1000 A
b1000 7
b100 6
b1100000000001100010011 5
1+
#400
0+
#450
b10010000000011 3
b10010000000011 8
b10000 .
b10000 ;
b10000 @
b1100 &
b1100 0
b1000 '
b1000 2
b11000101000001110110011 (
b11000101000001110110011 4
b10000 /
b10000 <
b10000 >
b1100 1
b1100 9
b1100 ?
b1100 A
b1100 7
b1000 6
b11000101000001110110011 5
1+
#500
0+
#550
b100000000010010010011 3
b100000000010010010011 8
b10100 .
b10100 ;
b10100 @
b10000 &
b10000 0
b1100 '
b1100 2
b10010000000011 (
b10010000000011 4
b10100 /
b10100 <
b10100 >
b10000 1
b10000 9
b10000 ?
b10000 A
b10000 7
b1100 6
b10010000000011 5
1+
#600
0+
#650
b100101000000010100110011 3
b100101000000010100110011 8
b11000 .
b11000 ;
b11000 @
b10100 &
b10100 0
b10000 '
b10000 2
b100000000010010010011 (
b100000000010010010011 4
b11000 /
b11000 <
b11000 >
b10100 1
b10100 9
b10100 ?
b10100 A
b10100 7
b10000 6
b100000000010010010011 5
1+
#700
0+
